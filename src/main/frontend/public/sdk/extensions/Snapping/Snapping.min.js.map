{"version":3,"sources":["webpack://Autodesk.Extensions.[name]/webpack/bootstrap","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/index.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/Snapper.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapMath.js","webpack://Autodesk.Extensions.[name]/./extensions/Snapping/SnapperIndicator.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","av","Autodesk","Viewing","namespace","AutodeskNamespace","_export","prop","require","SnappingExtension","viewer","options","this","loadExtension","Extension","theExtensionManager","registerExtension","MeasureCommon","EPSILON","SnapType","SnapResult","VertexBufferReader","Private","isEqualWithPrecision","a","b","Math","abs","isEqualVectorsWithPrecision","v1","v2","x","y","z","distancePointToLine","point","lineStart","lineEnd","equals","distanceTo","distance","param","X0","THREE","Vector3","X1","subVectors","dot","cross","sqrt","SnapCandidateType","Unknown","Line","CircularArc","EllipticalArc","SnapCandidate","viewportId","type","radius","radiusX","radiusY","center","startAngle","endAngle","p1","p2","clone","start","end","CirularArc","other","optionalTarget","isLine","intersectLines","Snapper","_snapResult","_viewer","setGlobalManager","globalManager","_names","_options","markupMode","toolName","_active","_distanceToEdge","Number","MAX_VALUE","_distanceToVertex","_isDragging","_isPressing","_isSnapped","_forcedVpId","_snapToPixel","indicator","SnapperIndicator","renderSnappedGeometry","renderSnappedTopology","detectRadiusInPixels","isMobileDevice","isActive","getNames","getName","getPriority","activate","deactivate","destroy","copyResults","destiny","copyTo","getEdge","geomEdge","getVertex","geomVertex","getGeometry","getGeometryType","geomType","getIntersectPoint","intersectPoint","getSnapResult","isSnapped","clearSnapped","clear","setViewportId","vpId","setSnapToPixel","enable","getSnapToPixel","snapping3D","result","snapNode","dbId","modelId","model","id","fragIds","face","fragId","undefined","length","hasTopology","snapping3DwithTopology","snapping3DtoMesh","getData","instanceTree","enumNodeFragments","push","geomFace","fi","mesh","impl","getRenderProxy","geometry","topoIndex","getTopoIndex","topology","getTopology","facesTopology","faces","edgesTopology","edges","faceSnappingWithTopology","normalMatrix","Matrix3","getNormalMatrix","matrixWorld","faceNormal","normal","applyMatrix3","normalize","edgeSnappingWithTopology","vertexSnappingWithTopology","setDetectRadius","forceSnapVertices","SNAP_VERTEX","forceSnapEdges","edgeIsCircle","circularArcCenter","circularArcRadius","vertices","SNAP_CIRCULARARC","edgeIsCurved","SNAP_CURVEDEDGE","SNAP_EDGE","faceIsCurved","SNAP_CURVEDFACE","SNAP_FACE","Face3","faceSnapping","applyMatrix","edgeSnapping","vertexSnapping","vA","vB","vC","geom","Geometry","attributes","index","positions","vb","position","array","stride","vbstride","indexList","faceId","j","set","vIndex","indices","ib","offsets","count","oi","Triangle","va","getTrianglesOnSameFace","isIncludeFace","vertexIndices","slice","vc","intersectFace","vCount","k","trianglesSharedEdge","ci","splice","a1","a2","a3","b1","b2","b3","c1","c2","c3","minDistTopoIndex","edgeGeom","minDist","applyMatrix4","dist","lineGeom","isEdge_12","isEdge_13","isEdge_23","minDistIndex","getConnectedLineSegmentsOnSameLine","edgeVertices","V0","V1","edge","dist1","dist2","add","divideScalar","V2","fN1","vA1","fN2","vA2","angleVector2","vector","atan","PI","GeometryCallback","snapper","aDetectRadius","circularArc","ellipticalArc","ellipticalArcCenter","vpIdLine","vpIdCircular","vpIdElliptical","detectRadius","snapCandidates","onLineSegment","x1","y1","x2","y2","fromLine","onCircularArc","cx","cy","Vector2","sub","pointOnArc","nearestPointOnCircularArc","fromCircularArc","angle","arc","CircleGeometry","Matrix4","makeTranslation","snapPoint","onEllipticalArc","major","minor","tilt","major1","minor1","major2","minor2","equation1","equation2","rx","ry","numPoints","Extensions","CompGeom","getEllipseArcPoint","createEllipticalArcGeometry","pop","nearestPoint","nearestVertexInVertexToEdge","makeEllipticalArc","snapping2D","Array","isArray","is3d","tr","is2d","getModelTransform","getInverseModelTransform","getFragmentList","gc","enumGeomsForObject","reverseMapDbId","finishSnapping2D","RASTER_PIXEL","results","Set","filter","forEach","res","getMaxScaleOnAxis","snapping2DOverlay","meshes","enumGeoms","snapping2DWithSegmentEnum","enumSegments","intersectSnap","candidates","snapRadius","sort","ca","cb","first","second","getIntersection","findIntersectionSnap","viewportIndex2d","SNAP_INTERSECTION","lineStripToPieces","mid","addVectors","md","sd","ed","SNAP_CIRCLE_CENTER","snappingRasterPixel","snapMidpoint","isMidpoint","midpoint","SNAP_MIDPOINT","setPerpendicular","isPerpendicular","navapi","navigation","camera","getCamera","getPosition","isPerspective","getEyeVector","fov","getVerticalFov","worldHeight","tan","degToRad","viewport","getScreenViewport","devicePixelRatio","getWindow","height","handleButtonDown","event","button","handleButtonUp","handleMouseMove","onMouseMove","canvasX","canvasY","handleSingleTap","handlePressHold","handleGesture","onMouseDown","mousePosition","snappingHitTest","vpVec","clientToViewport","intersectGroundViewport","isLeaflet","GlobalManagerMixin","outPoint","dir","copy","atan2","angleInsideArc","multiplyScalar","pStart","getEllipsePoint","pEnd","startIsCloser","distanceToSquared","p3","p4","checkInsideSegment","epsilon","denom","ua","ub","isEqualVectors","GEOMETRIES_OVERLAY","INDICATOR_OVERLAY","_point","overlayType","previewsIntersectPoint","createOverlayScene","geometryMaterial","MeshPhongMaterial","color","ambient","opacity","transparent","depthTest","depthWrite","side","DoubleSide","indicatorMaterial","MeshBasicMaterial","constructor","proto","render","snapResult","clearOverlay","isEmpty","renderGeometry","renderIndicator","removeOverlay","overlayName","removeOverlayScene","clearOverlays","addOverlay","drawFace","material","snapperPlane","Mesh","cylinderMesh","pointX","pointY","width","direction","orientation","lookAt","Object3D","up","multiply","cylinder","CylinderGeometry","drawPoint","drawLine","renderVertexIndicator","pos","getSnapResultPosition","setScale","rightVec","getCameraRightVector","upVec","getCameraUpVector","renderMidpointIndicator","renderEdgeIndicator","renderCircleIndicator","drawCircle","renderPerpendicular","renderPixelIndicator","setEdgeScale","SphereGeometry","pointMesh","setPointScale","torus","TorusGeometry","torusMesh","setCircleScale","scale","updatePointScale","overlay","overlayScenes","scene","children","updateEdgeScale","onCameraChange","dispose"],"mappings":"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","file":"Snapping/Snapping.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 322);\n","\nvar av = Autodesk.Viewing;\n\n/**\n * @namespace Autodesk.Viewing.Extensions.Snapping\n */\nvar namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Snapping');\n\nfunction _export(m, ns) {\n    for (var prop in m) {\n        if (m.hasOwnProperty(prop)) {\n            //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n            module.exports[prop] = m[prop];\n\n            //Export into the desired viewer namespace\n            ns[prop] = m[prop];\n        }\n    }\n}\n\n_export(require(\"./SnapMath.js\"), namespace);\n_export(require(\"./Snapper.js\"), namespace);\n_export(require(\"./SnapperIndicator.js\"), namespace);\n\n\n/**\n * Utility extension that provides access to the {@link Autodesk.Viewing.Extensions.Snapping.Snapper} tool.\n * \n * The extension id is: `Autodesk.Snapping`\n * \n * @example\n *   viewer.loadExtension('Autodesk.Snapping')\n *  \n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SnappingExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @class\n*/\nclass SnappingExtension extends av.Extension {\n\n    /**\n     * @alias Autodesk.Viewing.Extensions.SnappingExtension\n     * @constructor\n     */\n    constructor(viewer, options) {\n        super(viewer, options);\n    }\n\n    /**\n     * Load the extension.\n     *\n     * @returns {Promise} that resolves when dependent extension finishes loading.\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#load\n    */\n    load() { \n        // Load the required dependency (and return the pending load as the load completion Promise)\n        return this.viewer.loadExtension('Autodesk.CompGeom');\n    }\n\n    /**\n     * Unloads the extension.\n     * It does not unload dependent extensions.\n     *\n     * @returns {boolean} Always returns true\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#unload\n    */\n    unload() { return true; }\n\n\n    /**\n     * Unused method.\n     *\n     * @returns {boolean} Always returns true\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#activate\n    */\n    activate() { return true; }\n\n    /**\n     * Unused method.\n     *\n     * @returns {boolean} Always returns false\n     * \n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#deactivate\n    */\n    deactivate() { return false; }\n}\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.Snapping', SnappingExtension);\n\n","\nimport { SnapperIndicator } from \"./SnapperIndicator.js\";\nimport { nearestPointOnCircularArc, intersectLines } from \"./SnapMath.js\";\n\nconst MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\nconst SnapResult = MeasureCommon.SnapResult;\n\nvar SNAP_PRECISION = 0.001;\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\nconst VertexBufferReader = avp.VertexBufferReader;\n\nfunction isEqualWithPrecision(a, b) {\n    return Math.abs(a - b) <= SNAP_PRECISION;\n}\n\nfunction isEqualVectorsWithPrecision(v1, v2) {\n    return Math.abs(v1.x - v2.x) <= SNAP_PRECISION\n        && Math.abs(v1.y - v2.y) <= SNAP_PRECISION\n        && Math.abs(v1.z - v2.z) <= SNAP_PRECISION;\n}\n\nfunction isInverseVectorsWithPrecision(v1, v2) {\n    return Math.abs(v1.x + v2.x) <= SNAP_PRECISION\n        && Math.abs(v1.y + v2.y) <= SNAP_PRECISION\n        && Math.abs(v1.z + v2.z) <= SNAP_PRECISION;\n}\n\nfunction distancePointToLine(point, lineStart, lineEnd) {\n\n    if (lineStart.equals(lineEnd)) { // Degenerate line\n        return point.distanceTo(lineStart);\n    }\n\n    var X0 = new THREE.Vector3();\n    var X1 = new THREE.Vector3();\n    var distance;\n    var param;\n\n    X0.subVectors(lineStart, point);\n    X1.subVectors(lineEnd, lineStart);\n    param = X0.dot(X1);\n    X0.subVectors(lineEnd, lineStart);\n    param = -param / X0.dot(X0);\n\n    if (param < 0) {\n        distance = point.distanceTo(lineStart);\n    } else if (param > 1) {\n        distance = point.distanceTo(lineEnd);\n    } else {\n        X0.subVectors(point, lineStart);\n        X1.subVectors(point, lineEnd);\n        X0.cross(X1);\n        X1.subVectors(lineEnd, lineStart);\n\n        distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));\n    }\n\n    return distance;\n}\n\nconst SnapCandidateType = {\n    Unknown:       0,\n    Line:          1,\n    CircularArc:   2,\n    EllipticalArc: 3\n};\n\n// A SnapCandidate references a single segment (line or arc) that we could snap to.\nclass SnapCandidate {\n    constructor(viewportId, distance) {\n\n        this.type = SnapCandidateType.Unknown;\n        this.viewportId = viewportId;\n\n        // 2d distance between original (unsnapped) position and the geometry of this candidate.\n        this.distance = 0;\n\n        // {Vector2} Start/Endpoint - only for line segments\n        this.lineStart = null;\n        this.lineEnd   = null;\n\n        // Fixed radius - only for CircularArcs\n        this.radius = 0;\n        \n        // Separate radii - only for ellipse arcs\n        this.radiusX = 0; // = major radius - by convention\n        this.radiusY = 0;\n        \n        // Center point as Vector2 (for arcs)\n        this.center = null;\n\n        // Start/end angle for arcs: Ccw angle in radians. Angle 0 corresponds to direction x+.\n        this.startAngle = 0;\n        this.endAngle   = 0; \n    }\n\n    fromLine(p1, p2) {\n        this.type = SnapCandidateType.Line;\n        this.lineStart = p1.clone();\n        this.lineEnd   = p2.clone();\n        return this;\n    }\n\n    fromCircularArc(center, radius, start, end) {\n        this.type   = SnapCandidateType.CircularArc;\n        this.center = center.clone();\n        this.radius = radius;\n        this.start  = start;\n        this.end    = end;\n        return this;\n    }\n\n    fromEllipticalArc(center, radiusX, radiusY, start, end) {\n        this.type = SnapCandidateType.EllipticalArc;\n        this.center = center.clone();\n        this.radiusX = radiusX;\n        this.radiusY = radiusY;\n        this.start = start;\n        this.end = end;\n        return this;\n    }\n\n    isLine()          { return this.type === SnapCandidateType.Line; }\n    isCircularArc()   { return this.type === SnapCandidateType.CirularArc; }\n    isEllipticalArc() { return this.type === SnapCandidateType.EllipticalArc; }\n\n    // Checks if the snapGeometry of this candidate intersects with another one.\n    //  @param {SnapCandidate} other\n    //  @param {Vector2} [optionalTarget]\n    //  @returns {THREE.Vector2|null} Returns intersection point if there is one.\n    getIntersection(other, optionalTarget) {\n\n        if (this.isLine() && other.isLine()) {\n            // Note: We do the intersections on the whole line - not just the intersections.\n            // Reason is:\n            //  a) Otherwise, it would not snap if you are slightly outline of one line segment\n            //  b) By definition, we get only very close segment candidates anyway\n            return intersectLines(this.lineStart, this.lineEnd, other.lineStart, other.lineEnd, false, optionalTarget);\n        }\n        \n        // TODO: Currently, we only support snapping to line-line intersections\n    }\n};\n\n// Checks if we can snap to an intersection of two close segments (each can be a line or arcs).\n//  @param {SnapCandidate[]} candidates     - Snap candidate geometries collected in GeometryCallback. Assumed to be within snapRadius.\n//  @param {TREE.Vector3}    intersectPoint - Unsnapped original position\n//  @param {number}          snapRadius\n//  @returns {Object|null} If an intersection snap is found, the result contains:\n//                    {\n//                        viewportId  // number\n//                        snapPoint   // (THREE.Vector3)\n//                    }\nconst findIntersectionSnap = (candidates, intersectPoint, snapRadius) => {\n\n    // Sort snapping candidates by increasing distance\n    // Strictly speaking, we just need the best two ones. But the number of candidates within the snapping\n    // distance is generally small anyway - and working with a sorted array is more flexible to incrementally\n    // make the snapping smarter later.\n    const byDistance = (ca, cb) => ca.distance - cb.distance;\n    candidates.sort(byDistance);\n    \n    // Stop here if we don't have enough candidates for an intersection\n    if (candidates.length < 2) {\n        return null;\n    }\n\n    // Init result object\n    const result = {\n        // Just use the one of the first candidate. There is no unique viewportId when using an intersection.\n        viewportId: candidates[0].viewportId,\n\n        // Snapping happens in 2d - so we set z in advance and just keep the original value.\n        // Note: Snapper generally needs some revision if we use it for planes that are not perpendicular to the viewing direction.\n        snapPoint:  new THREE.Vector3(0, 0, intersectPoint.z)\n    };\n    \n    // Check for any candidate that intersects with the closest one we found\n    const first = candidates[0];\n    for (let i=1; i<candidates.length; i++) {\n        const second = candidates[i];\n\n        // Do intersection test. If found, write it to result.snapPoint\n        const found = first.getIntersection(second, result.snapPoint);\n        if (!found) {\n            continue;\n        }\n\n        // We found an intersection. Although we assume all candidates to be within\n        // snap radius already, the intersection may still be somewhere else.\n        // => Check if intersection is still within the snapRadius.\n        const dist = THREE.Vector2.prototype.distanceTo.call(result.snapPoint, intersectPoint);\n        if (dist < snapRadius) {\n            // We found a valid intersection snap\n            return result;\n        }\n    }\n    return null;\n};\n\n\n/**\n * A tool that lets users attach pointer events to vertices and edges. It supports 2D and 3D models.\n *\n * @memberof Autodesk.Viewing.Extensions.Snapping\n * @alias Autodesk.Viewing.Extensions.Snapping.Snapper\n * @constructor\n */\nexport function Snapper(viewer, options) {\n\n    var _snapResult = new SnapResult();\n\n    var _viewer = viewer;\n    this.setGlobalManager(viewer.globalManager);\n\n    var _options = options || {};\n    var _names;\n\n    if (_options.markupMode) {\n        _names = [\"snapper-markup\"];\n    } else if (_options.toolName) {\n        // Allow tools to use their own snapper\n        _names = [_options.toolName];\n    } else {\n        _names = [\"snapper\"];\n    }\n\n    var _priority = 60;\n\n    var _active = false;\n\n    var _distanceToEdge = Number.MAX_VALUE;\n    var _distanceToVertex = null;\n\n    var _isDragging = false;\n    var _isPressing = false;\n    var _isSnapped = false;\n\n    var _forcedVpId = null; // the viewport index of the first selection for 2D\n\n    var _snapToPixel = false;\n\n    this.indicator = new SnapperIndicator(viewer, this);\n\n    this.markupMode = _options.markupMode;\n    this.renderSnappedGeometry = _options.renderSnappedGeometry;\n    this.renderSnappedTopology = _options.renderSnappedTopology;\n\n    //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of\n    //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.\n    this.detectRadiusInPixels = av.isMobileDevice() ? 50 : 10;\n\n    /**\n     * @returns {boolean} true when the tool is active\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isActive\n     */\n    this.isActive = function() {\n        return _active;\n    };\n\n    this.getNames = function() {\n        return _names;\n    };\n\n    this.getName = function() {\n        return _names[0];\n    };\n\n    this.getPriority = function() {\n        return _priority;\n    };\n\n    /**\n     * Starts intercepting pointer events.\n     * Invoked automatically by the {@link ToolController}.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#activate\n     */\n    this.activate = function() {\n        _active = true;\n\n        if (!this.indicator) {\n            this.indicator = new SnapperIndicator(viewer, this);\n        }\n    };\n\n\n    /**\n     * Stops intercepting pointer events.\n     * Invoked automatically by the {@link ToolController}.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#deactivate\n     */\n    this.deactivate = function() {\n        _active = false;\n\n        if (this.indicator) {\n            this.indicator.destroy();\n            this.indicator = null;    \n        }        \n    };\n\n    this.copyResults = function(destiny) {\n        _snapResult.copyTo(destiny);\n    };\n\n    this.getEdge = function() {\n        return _snapResult.geomEdge;\n    };\n\n    this.getVertex = function() {\n        return _snapResult.geomVertex;\n    };\n\n    this.getGeometry = function() {\n        return _snapResult.getGeometry();\n    };\n\n    this.getGeometryType = function() {\n        return _snapResult.geomType;\n    };\n\n    this.getIntersectPoint = function() {\n        return _snapResult.intersectPoint;\n    };\n\n\n    /**\n     * @returns {SnapResult} The snapping status of the last pointer event performed.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#getSnapResult\n     */\n    this.getSnapResult = function() {\n        return _snapResult;\n    };\n\n    /**\n     * Checks whether the tool's last update resulted on a snap.\n     *\n     * @returns {boolean} true when the last pointer event got snapped.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isSnapped\n     */\n    this.isSnapped = function() {\n        return _isSnapped;\n    };\n\n    this.clearSnapped = function() {\n        _snapResult.clear();\n        _isSnapped = false;\n    };\n\n    this.setViewportId = function(vpId) {\n        _forcedVpId = vpId;\n    };\n\n    this.setSnapToPixel = function(enable) {\n        _snapToPixel = enable;\n    };\n\n    this.getSnapToPixel = function() {\n        return _snapToPixel;\n    };\n\n    /**\n     * 3D Snapping\n     * @param result -Result of Hit Test.\n     */\n    this.snapping3D = function(result) {\n\n        _snapResult.snapNode = result.dbId;\n        _snapResult.intersectPoint = result.intersectPoint;\n        _snapResult.modelId = result.model ? result.model.id : null;\n\n        // Avoid crash if the hit test does not belong to a model. This may happen, if a 3D overlay was hit (see Viewer3DImpl.rayIntersect).\n        if (!result.model) {\n            return;\n        }\n\n        var face = result.face;\n        var fragIds;\n\n        if (!result.fragId || result.fragId.length === undefined) {\n            fragIds = [result.fragId];\n        } else {\n            fragIds = result.fragId;\n        }\n\n        // This is for Fusion model with topology data\n        _snapResult.hasTopology = result.model.hasTopology();\n        if (_snapResult.hasTopology) {\n            this.snapping3DwithTopology(face, fragIds, result.model);\n        } else {\n           this.snapping3DtoMesh(face, fragIds, result.model);\n        }\n    };\n\n    /**\n     * Snapping order is: 1st vertices, 2nd edges, 3rd and final faces.\n     */\n    this.snapping3DwithTopology = function(face, fragIds, model) {\n\n        // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.\n        if (_snapResult.snapNode) {\n            fragIds = [];\n\n            model.getData().instanceTree.enumNodeFragments(_snapResult.snapNode, function(fragId) {\n                fragIds.push(fragId);\n            }, true);\n        }\n\n        _snapResult.geomFace = _snapResult.geomEdge = _snapResult.geomVertex = null;\n        _distanceToEdge = Number.MAX_VALUE;\n\n        for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var fragId = fragIds[fi];\n            var mesh = _viewer.impl.getRenderProxy(model, fragId);\n            var geometry = mesh.geometry;\n\n            var topoIndex = model.getTopoIndex(fragId);\n            var topology = model.getTopology(topoIndex);\n            var facesTopology = topology.faces;\n            var edgesTopology = topology.edges;\n\n            if (!_snapResult.geomFace) {\n                _snapResult.geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, mesh);\n\n                if (_snapResult.geomFace) {\n                    _snapResult.geomFace.fragId = fragId;\n                }\n\n                var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n                _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n            }\n\n            // Need to iterate all frags with same dbId, because when meshes are attached with each other, \n            // edge-topology data will only be on one mesh.\n            this.edgeSnappingWithTopology(_snapResult.intersectPoint, geometry, edgesTopology, mesh);\n\n        }\n\n        _snapResult.geomVertex = this.vertexSnappingWithTopology(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n        if (_snapResult.geomFace) {\n\n            // Determine which one should be drawn: face , edge or vertex\n            _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n            if ((_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) && _snapResult.geomVertex) {\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if ((_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) && _snapResult.geomEdge) {\n\n                var center = this.edgeIsCircle(_snapResult.geomEdge);\n                if (center) {\n                    _snapResult.circularArcCenter = center;\n                    _snapResult.circularArcRadius = center.distanceTo(_snapResult.geomEdge.vertices[0]);\n                    _snapResult.geomEdge.center = _snapResult.circularArcCenter;\n                    _snapResult.geomEdge.radius = _snapResult.circularArcRadius;\n                    _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n                }\n                else if (this.edgeIsCurved(_snapResult.geomEdge)) {\n                    _snapResult.geomType = SnapType.SNAP_CURVEDEDGE;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n\n            }\n            else {\n\n                if (this.faceIsCurved(_snapResult.geomFace)) {\n                    _snapResult.geomType = SnapType.SNAP_CURVEDFACE;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_FACE;\n                }\n\n            }\n            \n            _isSnapped = true;\n        }\n    };\n\n    this.snapping3DtoMesh = function(face, fragIds, model) {\n         for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var fragId = fragIds[fi];\n            var mesh = _viewer.impl.getRenderProxy(model, fragId);\n            var geometry = mesh.geometry;\n\n            // Note that face may also be a line {a, b} (see lineRayCast(..) in VBIntersector.js\n            if (face instanceof THREE.Face3) {\n                _snapResult.geomFace = this.faceSnapping(face, geometry);\n            }\n\n            if (!_snapResult.geomFace)\n                continue;\n\n            _snapResult.geomFace.applyMatrix(mesh.matrixWorld);\n            _snapResult.geomEdge = this.edgeSnapping(_snapResult.geomFace, _snapResult.intersectPoint);\n            _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n            var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n            _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n\n            // Determine which one should be drawn: face , edge or vertex\n            _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n            if ((_options.forceSnapVertices || (_distanceToVertex < _snapResult.radius))) {\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (_options.forceSnapEdges || (_distanceToEdge < _snapResult.radius)) {\n                _snapResult.geomType = SnapType.SNAP_EDGE;\n            }\n            else {\n                _snapResult.geomType = SnapType.SNAP_FACE;\n            }\n\n            _isSnapped = true;\n            break;\n        }\n    };\n\n    this.faceSnappingWithTopology = function(face, geometry, facesTopology, mesh) {\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n        var vC = new THREE.Vector3();\n\n        var geom = new THREE.Geometry();\n\n        var attributes = geometry.attributes;\n\n        if (attributes.index !== undefined) {\n\n            var positions = geometry.vb ? geometry.vb : attributes.position.array;\n            var stride = geometry.vb ? geometry.vbstride : 3;\n\n            // Find the index of face topology list which includes the intersect face(triangle)\n            for (var i = 0; i < facesTopology.length; i++) {\n\n                var indexList = facesTopology[i].indexList;\n                var faceId = facesTopology[i].id;\n                for (var j = 0; j < indexList.length; j += 3) {\n\n                    if (face.a === indexList[j]) {\n                        if ((face.b === indexList[j + 1] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j + 1])) {\n                            break;\n                        }\n                    }\n                    else if (face.a === indexList[j + 1]) {\n                        if ((face.b === indexList[j] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j])) {\n                            break;\n                        }\n                    }\n                    else if (face.a === indexList[j + 2]) {\n                        if ((face.b === indexList[j] && face.c === indexList[j + 1]) || (face.b === indexList[j + 1] && face.c === indexList[j])) {\n                            break;\n                        }\n                    }\n                }\n\n                if (j < indexList.length) {\n                    break;\n                }\n            }\n\n            if (i < facesTopology.length) {\n\n                for (var j = 0; j < indexList.length; j += 3) {\n                    vA.set(\n                        positions[ indexList[j] * stride ],\n                        positions[ indexList[j] * stride + 1 ],\n                        positions[ indexList[j] * stride + 2 ]\n                    );\n                    vB.set(\n                        positions[ indexList[j + 1] * stride ],\n                        positions[ indexList[j + 1] * stride + 1 ],\n                        positions[ indexList[j + 1] * stride + 2 ]\n                    );\n                    vC.set(\n                        positions[ indexList[j + 2] * stride ],\n                        positions[ indexList[j + 2] * stride + 1 ],\n                        positions[ indexList[j + 2] * stride + 2 ]\n                    );\n\n                    var vIndex = geom.vertices.length;\n\n                    geom.vertices.push(vA.clone());\n                    geom.vertices.push(vB.clone());\n                    geom.vertices.push(vC.clone());\n\n                    geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n                }\n            }\n        }\n\n        //console.log(face);\n\n        if (geom.vertices.length > 0) {\n\n            geom.faceId = faceId;\n            geom.applyMatrix(mesh.matrixWorld);\n            return geom;\n        }\n        else {\n\n            return null;\n        }\n\n    };\n\n    /**\n     * Find the closest face next to the cast ray\n     * @param {THREE.Face3} face - the intersect triangle of Hit Test.\n     * @param geometry - the geometry of mesh\n     *\n     * @private\n     */\n    this.faceSnapping = function(face, geometry) {\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n        var vC = new THREE.Vector3();\n\n        var geom = new THREE.Geometry();  //Geometry which includes all the triangles on the same plane.\n\n\n\n        var attributes = geometry.attributes;\n\n        var indices = attributes.index && (attributes.index.array || geometry.ib);\n        var positions = geometry.vb ? geometry.vb : attributes.position.array;\n        var stride = geometry.vb ? geometry.vbstride : 3;\n        var offsets = geometry.offsets;\n\n        if ( !offsets || offsets.length === 0) {\n\n            offsets = [{start: 0, count: indices ? indices.length : positions.length, index: 0}];\n\n        }\n\n        for (var oi = 0; oi < offsets.length; ++oi) {\n\n            var start = offsets[oi].start;\n            var count = offsets[oi].count;\n            var index = offsets[oi].index;\n\n            for (var i = start; i < start + count; i += 3) {\n\n                var a = index + (indices ? indices[i] : i);\n                var b = index + (indices ? indices[i + 1] : i + 1);\n                var c = index + (indices ? indices[i + 2] : i + 2);\n\n                vA.set(\n                    positions[a * stride],\n                    positions[a * stride + 1],\n                    positions[a * stride + 2]\n                );\n                vB.set(\n                    positions[b * stride],\n                    positions[b * stride + 1],\n                    positions[b * stride + 2]\n                );\n                vC.set(\n                    positions[c * stride],\n                    positions[c * stride + 1],\n                    positions[c * stride + 2]\n                );\n\n                var faceNormal = THREE.Triangle.normal(vA, vB, vC);\n\n                var va = new THREE.Vector3();\n                va.set(\n                    positions[ face.a * stride ],\n                    positions[ face.a * stride + 1 ],\n                    positions[ face.a * stride + 2 ]\n                );\n\n                if (isEqualVectorsWithPrecision(faceNormal, face.normal) && isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))\n                {\n\n                    var vIndex = geom.vertices.length;\n\n                    geom.vertices.push(vA.clone());\n                    geom.vertices.push(vB.clone());\n                    geom.vertices.push(vC.clone());\n\n                    geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n                }\n            }\n        }\n\n        if (geom.vertices.length > 0) {\n\n            return this.getTrianglesOnSameFace(geom, face, positions, stride);\n        }\n        else {\n\n            return null;\n        }\n    };\n\n    /**\n     * Find triangles on the same face with the triangle intersected with the cast ray\n     * @param geom -Geometry which includes all the triangles on the same plane.\n     * @param face -Triangle which intersects with the cast ray.\n     * @param positions -Positions of all vertices.\n     * @param stride -Stride for the interleaved buffer.\n     *\n     * @private\n     */\n    this.getTrianglesOnSameFace = function(geom, face, positions, stride) {\n\n        var isIncludeFace = false; // Check if the intersect face is in the mesh\n        var vertexIndices = geom.vertices.slice();\n\n        var va = new THREE.Vector3();\n        va.set(\n            positions[ face.a * stride ],\n            positions[ face.a * stride + 1 ],\n            positions[ face.a * stride + 2 ]\n        );\n        var vb = new THREE.Vector3();\n        vb.set(\n            positions[ face.b * stride ],\n            positions[ face.b * stride + 1 ],\n            positions[ face.b * stride + 2 ]\n        );\n        var vc = new THREE.Vector3();\n        vc.set(\n            positions[ face.c * stride ],\n            positions[ face.c * stride + 1 ],\n            positions[ face.c * stride + 2 ]\n        );\n        var intersectFace = new THREE.Geometry();\n        intersectFace.vertices.push(va);\n        intersectFace.vertices.push(vb);\n        intersectFace.vertices.push(vc);\n        intersectFace.faces.push(new THREE.Face3(0, 1, 2));\n\n        var vCount = [];\n\n        do {\n\n            vCount = [];\n\n            for (var j = 0; j < vertexIndices.length; j += 3) {\n\n                // The triangle which is intersected with the ray\n                if (vertexIndices[j].equals(va) && vertexIndices[j + 1].equals(vb) && vertexIndices[j + 2].equals(vc)) {\n\n                    isIncludeFace = true;\n                    vCount.push(j);\n                    continue;\n                }\n\n                for (var k = 0; k < intersectFace.vertices.length; k += 3) {\n\n                    // The triangles which are on the same face with the intersected triangle\n                    if (this.trianglesSharedEdge(vertexIndices[j], vertexIndices[j + 1], vertexIndices[j + 2],\n                            intersectFace.vertices[k], intersectFace.vertices[k + 1], intersectFace.vertices[k + 2])) {\n\n                        var vIndex = intersectFace.vertices.length;\n                        intersectFace.vertices.push(vertexIndices[j].clone());\n                        intersectFace.vertices.push(vertexIndices[j + 1].clone());\n                        intersectFace.vertices.push(vertexIndices[j + 2].clone());\n                        intersectFace.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n\n                        vCount.push(j);\n                        break;\n                    }\n                }\n            }\n\n            for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n                vertexIndices.splice(vCount[ci], 3);\n\n            }\n\n        } while (vCount.length > 0);\n\n        if (isIncludeFace) {\n            return intersectFace;\n        }\n        else {\n            return null;\n        }\n\n    };\n\n    /**\n     * Check if the two triangle share edge, the inputs are their vertices\n     *\n     * @private\n     */\n    this.trianglesSharedEdge = function(a1, a2, a3, b1, b2, b3) {\n\n        var c1 = false;\n        var c2 = false;\n        var c3 = false;\n\n        if (a1.equals(b1) || a1.equals(b2) || a1.equals(b3)) {\n            c1 = true;\n        }\n        if (a2.equals(b1) || a2.equals(b2) || a2.equals(b3)) {\n            c2 = true;\n        }\n        if (a3.equals(b1) || a3.equals(b2) || a3.equals(b3)) {\n            c3 = true;\n        }\n\n        if (c1 & c2 || c1 & c3 || c2 & c3) {\n            return true;\n        }\n\n        return false;\n    };\n\n    this.edgeSnappingWithTopology = function(intersectPoint, geometry, edgesTopology, mesh) {\n\n        var edgeGeom = new THREE.Geometry();\n        var minDistTopoIndex;\n        var minDist = Number.MAX_VALUE;\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n\n        var attributes = geometry.attributes;\n\n        if (attributes.index !== undefined && edgesTopology != undefined) {\n\n            var positions = geometry.vb ? geometry.vb : attributes.position.array;\n            var stride = geometry.vb ? geometry.vbstride : 3;\n\n            // Find the index of edge topology list which includes the nearest edge segment to the intersect point\n            for (var i = 0; i < edgesTopology.length; i++) {\n\n                var indexList = edgesTopology[i].indexList;\n                // In edges topology index list the type is LineStrip\n                for (var j = 0; j < indexList.length - 1; j++) {\n                    vA.set(\n                        positions[ indexList[j] * stride ],\n                        positions[ indexList[j] * stride + 1 ],\n                        positions[ indexList[j] * stride + 2 ]\n                    );\n                    vB.set(\n                        positions[ indexList[j + 1] * stride ],\n                        positions[ indexList[j + 1] * stride + 1 ],\n                        positions[ indexList[j + 1] * stride + 2 ]\n                    );\n\n                    vA.applyMatrix4(mesh.matrixWorld);\n                    vB.applyMatrix4(mesh.matrixWorld);\n\n                    var dist = distancePointToLine(intersectPoint, vA, vB);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        minDistTopoIndex = i;\n                    }\n                }\n            }\n\n            if (minDistTopoIndex) {\n                indexList = edgesTopology[minDistTopoIndex].indexList;\n                for (var k = 0; k < indexList.length - 1; k++) {\n                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k] * stride], positions[indexList[k] * stride + 1], positions[indexList[k] * stride + 2]));\n                    // To make the line's type to LinePieces which is used by drawLine function\n                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k + 1] * stride], positions[indexList[k + 1] * stride + 1], positions[indexList[k + 1] * stride + 2]));\n                }\n            }\n        }\n\n        if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {\n\n            _distanceToEdge = minDist;\n            edgeGeom.applyMatrix(mesh.matrixWorld);\n            _snapResult.geomEdge = edgeGeom;\n        }\n    };\n\n    /**\n     * Find the closest edge next to the intersect point\n     * @param face -Face which is found by faceSnapping.\n     * @param intersectPoint -IntersectPoint between cast ray and face.\n     * @param mesh -The whole mesh of one fragment.\n     *\n     * @private\n     */\n    this.edgeSnapping = function(face, intersectPoint) {\n\n        var lineGeom = new THREE.Geometry();\n        var isEdge_12 = true;\n        var isEdge_13 = true;\n        var isEdge_23 = true;\n\n        for (var i = 0; i < face.vertices.length; i += 3) {\n\n            for (var j = 0; j < face.vertices.length; j += 3) {\n\n                if ( i !== j ) {\n                    // Check edge 12\n                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])\n                        || face.vertices[i].equals(face.vertices[j + 2]))\n                        && (face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])\n                        || face.vertices[i + 1].equals(face.vertices[j + 2]))) {\n\n                        isEdge_12 = false;\n\n                    }\n                    // Check edge 13\n                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])\n                        || face.vertices[i].equals(face.vertices[j + 2]))\n                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])\n                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n                        isEdge_13 = false;\n\n                    }\n                    // Check edge 23\n                    if ((face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])\n                        || face.vertices[i + 1].equals(face.vertices[j + 2]))\n                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])\n                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {\n\n                        isEdge_23 = false;\n\n                    }\n                }\n            }\n\n            if (isEdge_12) {\n\n                lineGeom.vertices.push(face.vertices[i].clone());\n                lineGeom.vertices.push(face.vertices[i + 1].clone());\n\n            }\n            if (isEdge_13) {\n\n                lineGeom.vertices.push(face.vertices[i].clone());\n                lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n            }\n            if (isEdge_23) {\n\n                lineGeom.vertices.push(face.vertices[i + 1].clone());\n                lineGeom.vertices.push(face.vertices[i + 2].clone());\n\n            }\n\n            isEdge_12 = true;\n            isEdge_13 = true;\n            isEdge_23 = true;\n\n        }\n\n        //return lineGeom;\n\n        var edgeGeom = new THREE.Geometry();\n        var minDistIndex;\n        var minDist = Number.MAX_VALUE;\n\n        for (var k = 0; k < lineGeom.vertices.length; k += 2) {\n\n            var dist = distancePointToLine(intersectPoint, lineGeom.vertices[k], lineGeom.vertices[k + 1]);\n\n            if (dist < minDist) {\n                minDist = dist;\n                minDistIndex = k;\n            }\n\n        }\n\n        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex ].clone());\n        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex + 1 ].clone());\n\n        edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeGeom.vertices);\n\n        _distanceToEdge = minDist;\n\n        return edgeGeom;\n\n    };\n\n    this.getConnectedLineSegmentsOnSameLine = function(lineGeom, edgeVertices) {\n\n        var vertices = lineGeom.vertices.slice();\n        var va = edgeVertices[0];\n        var vb = edgeVertices[1];\n\n        var vCount = [];\n\n        do {\n\n            vCount = [];\n\n            for (var j = 0; j < vertices.length; j += 2) {\n\n                // The line which has min distance to intersection point\n                if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {\n\n                    continue;\n                }\n\n                for (var k = 0; k < edgeVertices.length; k += 2) {\n\n                    // The line segments which are connected on the same line\n                    if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||\n                        vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {\n\n                        var V0 = new THREE.Vector3();\n                        var V1 = new THREE.Vector3();\n\n                        V0.subVectors(edgeVertices[k],  edgeVertices[k + 1]);\n                        V0.normalize();\n                        V1.subVectors(vertices[j],vertices[j + 1]);\n                        V1.normalize();\n\n                        //if (V0.equals(V1) || V0.equals(V1.negate())) {\n                        if (isEqualVectorsWithPrecision(V0, V1) || isInverseVectorsWithPrecision(V0, V1))\n                        {\n\n                            vCount.push(j);\n                            break;\n\n                        }\n                    }\n                }\n            }\n\n            for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n                edgeVertices.push(vertices[ vCount[ci] ]);\n                edgeVertices.push(vertices[ vCount[ci] + 1 ]);\n                vertices.splice(vCount[ci], 2);\n\n            }\n\n        } while (vCount.length > 0);\n\n        return edgeVertices;\n\n    };\n\n    this.vertexSnappingWithTopology = function(edge, intersectPoint) {\n\n        var minDist = Number.MAX_VALUE;\n        var point = new THREE.Vector3();\n\n        if (edge && edge.vertices.length > 1) {\n            var dist1 = intersectPoint.distanceTo(edge.vertices[0]);\n            var dist2 = intersectPoint.distanceTo(edge.vertices[edge.vertices.length - 1]);\n\n            if (dist1 <= dist2) {\n                minDist = dist1;\n                point = edge.vertices[0].clone();\n            }\n            else {\n                minDist = dist2;\n                point = edge.vertices[edge.vertices.length - 1].clone();\n            }\n        }\n\n        _distanceToVertex = minDist;\n\n        return point;\n    };\n\n    /**\n     * Find the closest vertex next to the intersect point\n     * @param edge -Edge which is found by edgeSnapping.\n     * @param intersectPoint -IntersectPoint between cast ray and face.\n     *\n     * @private\n     */\n    this.vertexSnapping = function(edge, intersectPoint) {\n\n        var minDist = Number.MAX_VALUE;\n        var point = new THREE.Vector3();\n\n        for (var i = 0; i < edge.vertices.length; ++i) {\n\n            var dist = intersectPoint.distanceTo(edge.vertices[i]);\n\n            if (dist < minDist - SNAP_PRECISION) {\n\n                minDist = dist;\n                point = edge.vertices[i].clone();\n\n            }\n        }\n\n        _distanceToVertex = minDist;\n\n        return point;\n    };\n\n    // This is only a workaround to detect if an edge is circle\n    this.edgeIsCircle = function(edge) {\n\n        var vertices = edge.vertices;\n\n        // Exclude squares and regular polygons\n        if (vertices.length < 8) {\n            return false;\n        }\n\n        if (vertices[0].equals(vertices[vertices.length - 1])) {\n\n            var center = new THREE.Vector3(0, 0, 0);\n            for (var i = 0; i < vertices.length; i += 2) {\n                center.add(vertices[i]);\n            }\n            center.divideScalar(vertices.length / 2.0);\n\n            var radius = center.distanceTo(vertices[0]);\n            for (var i = 0; i < vertices.length; i += 2) {\n                if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {\n                    continue;\n                }\n                else {\n                    return false;\n                }\n            }\n            return center;\n        }\n        else {\n            return false;\n        }\n    };\n\n    this.edgeIsCurved = function (edge) {\n\n        var vertices = edge.vertices;\n\n        if (vertices.length <= 2) {\n            return false;\n        }\n        else if (vertices[0].equals(vertices[vertices.length - 1])) {\n            return true;\n        }\n        else {\n            var V1 = new THREE.Vector3();\n            V1.subVectors(vertices[0], vertices[1]);\n\n            var V2 = new THREE.Vector3();\n            for (var i = 2; i < vertices.length; i += 2) {\n                V2.subVectors(vertices[i], vertices[i + 1]);\n                if (!isEqualVectorsWithPrecision(V1, V2)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    };\n\n    this.faceIsCurved = function (face) {\n\n        var vertices = face.vertices;\n        var faces = face.faces;\n\n        if (faces.length <= 1) {\n            return false;\n        }\n        else {\n            var fN1 = THREE.Triangle.normal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c]);\n            var vA1 = vertices[faces[0].a];\n\n            for (var i = 1; i < faces.length; i++) {\n                var fN2 = THREE.Triangle.normal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c]);\n                var vA2 = vertices[faces[i].a];\n\n                if (!isEqualVectorsWithPrecision(fN1, fN2) || !isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    };\n\n    this.angleVector2 = function(vector) {\n\n        if (vector.x > 0 && vector.y >= 0) {\n            return Math.atan(vector.y / vector.x);\n        }\n        else if (vector.x >= 0 && vector.y < 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI * 2;\n        }\n        else if (vector.x < 0 && vector.y <= 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI;\n        }\n        else if (vector.x <= 0 && vector.y > 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI;\n        }\n        else{ // x = 0, y = 0\n            return null;\n        }\n    };\n\n    // Creates a THREE.Geometry that represents an approximation of a given elliptical arc in {z=0} plane.\n    // Points are obtained by by uniform sampling of a given elliptical arc.\n    //  @param {number} numPoints - The length number of points that the output geometry will contain. segments in which we subdivide the arc. Resulting point count is numSegments+1.\n    // See getEllipseArcPoint() for param details.\n    const createEllipticalArcGeometry = (cx, cy, rx, ry, startAngle, endAngle, numPoints) => {\n        const geometry = new THREE.Geometry();\n        for (let i=0; i<numPoints; i++) {\n            const p = new THREE.Vector3(0,0,0);\n            const t = i/(numPoints-1);\n            Autodesk.Extensions.CompGeom.getEllipseArcPoint(t, cx, cy, rx, ry, startAngle, endAngle, 0.0, p);\n            geometry.vertices.push(p);\n        }\n        return geometry;\n    };\n\n    function GeometryCallback(viewer, snapper, aDetectRadius) {\n        this.viewer = viewer;\n        this.snapper = snapper;\n\n        this.lineGeom = new THREE.Geometry();\n        this.circularArc = null;\n        this.circularArcCenter;\n        this.circularArcRadius;\n        this.ellipticalArc = null;\n        this.ellipticalArcCenter;\n\n        this.minDist = Number.MAX_VALUE;\n\n        this.vpIdLine = null;\n        this.vpIdCircular = null;\n        this.vpIdElliptical = null;\n\n        this.detectRadius = aDetectRadius;\n\n        // Collects candidate segments that we can snap to.\n        // This is used to allow snapping to segment intersections.\n        this.snapCandidates = []; // {SnappingCandidate[]}\n    }\n\n    GeometryCallback.prototype.onLineSegment = function(x1, y1, x2, y2, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var vertices = this.lineGeom.vertices;\n        var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);\n        var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);\n\n        // Skip segments outside detectRadius\n        var dist = distancePointToLine(intersectPoint, v1, v2);\n        if (dist > this.detectRadius) {\n            return;\n        }\n\n        // Collect snap candidate\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).fromLine(v1, v2));\n\n        // Track minDist and lineGeometry for best hit so far\n        if (dist < this.minDist) {\n\n            vertices.splice(0, 2, v1, v2);\n            this.minDist = dist;\n\n            this.vpIdLine = vpId;\n        }\n    };\n\n    GeometryCallback.prototype.onCircularArc = function(cx, cy, start, end, radius, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n        var center = new THREE.Vector2(cx, cy);\n        point.sub(center);\n\n        // Compute closest point on arc\n        const pointOnArc = nearestPointOnCircularArc(intersectPoint, center, radius, start, end);\n        const dist       = pointOnArc.distanceTo(intersectPoint); // 2D distance\n\n        // Collect snap candidate\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).fromCircularArc(center, radius, start, end));\n\n        // Skip arcs outside detectRadius\n        if (dist > this.detectRadius) {\n            return;\n        }\n\n        // TODO: get rid of the CircleGeometry stuff below, because we computed the snapPoint above already.\n        //       But this needs some refactoring, because the Geometry is passed around outside of snapper.\n\n        var angle = this.snapper.angleVector2(point);\n\n        if (end > start && angle >= start && angle <= end) {\n            var arc = new THREE.CircleGeometry(radius, 100, start, end - start);\n        }\n        else if (end < start && (angle >= start || angle <= end)) {\n            var arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);\n        }\n        else {\n            return;\n        }\n        arc.vertices.splice(0, 1);\n        arc.applyMatrix(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));\n        this.circularArc = arc;\n        this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n        this.circularArcRadius = radius;\n\n        this.snapPoint = new THREE.Vector3(pointOnArc.x, pointOnArc.y, intersectPoint.z);\n\n        this.vpIdCircular = vpId;\n    };\n\n    GeometryCallback.prototype.onEllipticalArc = function(cx, cy, start, end, major, minor, tilt, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n        var major1 = major - this.detectRadius;\n        var minor1 = minor - this.detectRadius;\n        var major2 = major + this.detectRadius;\n        var minor2 = minor + this.detectRadius;\n\n        var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);\n        var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);\n\n        var center = new THREE.Vector2(cx, cy);\n        point.sub(center);\n        point.x *= minor;\n        point.y *= major;\n        var angle = this.snapper.angleVector2(point);\n\n        if (end > Math.PI * 2) {\n            end = Math.PI * 2;\n        }\n\n        if (equation1 >= 1 && equation2 <= 1) {\n\n            if ((end > start && angle >= start && angle <= end) || (end < start && (angle >= start || angle <= end))){\n                var arc = createEllipticalArcGeometry(cx, cy, major, minor, start, end, 50);\n                if (!isEqualWithPrecision(end - start, Math.PI * 2))\n                {\n                    arc.vertices.pop();\n                }\n                arc.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));\n\n                // Compute distance between geometry and snapped point. \n                // We use the same way here as in getSnapResultPosition(). This will be replaced later by a more accurate solution.\n                const nearestPoint = nearestVertexInVertexToEdge(intersectPoint, arc);\n                const dist = THREE.Vector2.prototype.distanceTo.call(nearestPoint, intersectPoint); // only in x/y\n\n                // Collect snap candidate\n                const center = new THREE.Vector2(cx, cy)\n                this.snapCandidates.push(new SnapCandidate(vpId, dist).makeEllipticalArc(center, major, minor, start, end));\n\n                // Todo: Unlike for line-segments, arcs are currently collected by \"last one wins\" rule by the code for single-snapping. \n                //       We should consider the distance here as well.\n                this.ellipticalArc = arc;\n                this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n\n                this.vpIdElliptical = vpId;\n            }\n        }\n    };\n\n    this.snapping2D = function(result) {\n\n        if (!result) {\n            return;\n        }\n        \n        var intersectPoint = result.intersectPoint;\n        var fragIds = result.fragId;\n\n        if (typeof fragIds === \"undefined\") {\n            return;\n        }\n        else if (!Array.isArray(fragIds)) {\n            fragIds = [fragIds];\n        }\n\n        const model = result.model ? result.model : _viewer.model;\n        if (model.is3d()) {\n            return;\n        }\n        _snapResult.modelId = result.model ? result.model.id : null;\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n        let tr;\n        if (!_viewer.impl.is2d) {\n            tr = model.getModelTransform();\n            // If there's a transform, move point to original location in sheet (will be restored at the end)\n            if (tr) {\n                _snapResult.intersectPoint = intersectPoint.clone();\n                _snapResult.intersectPoint.applyMatrix4(model.getInverseModelTransform());\n            }\n        }\n\n        // Determine which one should be drawn: line, circular arc or elliptical arc\n        _snapResult.radius = this.setDetectRadius(intersectPoint); // Use the un-transformed point\n\n        // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.\n        var supportsGeomSnapping = (model.getFragmentList()!=null);\n        if (!supportsGeomSnapping) {\n\n            // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure\n            // distances between arbitrary points in rasters.\n            _isSnapped = true;\n            _snapResult.geomType = SnapType.SNAP_VERTEX;\n            _snapResult.geomVertex = intersectPoint; // Use the un-transformed point\n            tr &&_snapResult.intersectPoint.applyMatrix4(tr); // Restore to original location\n            return;\n        }\n\n\n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n        for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var mesh = _viewer.impl.getRenderProxy(model, fragIds[fi]);\n\n            if (mesh && mesh.geometry) {\n                var vbr = new VertexBufferReader(mesh.geometry);\n                vbr.enumGeomsForObject(_viewer.model.reverseMapDbId(result.dbId), gc);\n            }\n        }\n\n        // _snapResult.intersectPoint contains the possibly transformed point\n        this.finishSnapping2D(gc, _snapResult.intersectPoint);\n\n        // Snap the unsnapped point only if the snapping fails\n        if(!_isSnapped && _snapToPixel) {\n            _isSnapped = true;\n            _snapResult.geomType = SnapType.RASTER_PIXEL;\n            _snapResult.geomVertex = _snapResult.intersectPoint;\n        }\n\n        if (tr) {\n            let results = [_snapResult.snapPoint, _snapResult.geomVertex, _snapResult.intersectPoint, _snapResult.circularArcCenter,\n                _snapResult.geomEdge?.vertices[0], _snapResult.geomEdge?.vertices[1]];\n            // Remove undefined and possibly shared vectors\n            results = [...new Set(results.filter(n => n))];\n            results.forEach(res => res.applyMatrix4(tr));\n            if (_snapResult.circularArcRadius) {\n                _snapResult.circularArcRadius *= tr.getMaxScaleOnAxis();\n            }\n        }\n    };\n\n    // By default, snapper only considers model geometry that is written to ID buffer.\n    // This function performs the 2D snapping on a set of given 2D meshes instead. It works similar to snapping2D() but \n    // enumerates the given meshes instead of getting them from the fragment list.\n    //\n    //  @param {THREE.Vector3}                 intersectPoint - click position in world-coords\n    //  @param {function(dbId, layerId, vpId)} filter - Defines subset of primitives to be considered.\n    //  @param {THREE.Mesh[]}                  meshes - The triangulated 2D shapes to be checked for snapping\n    //  @param {number}                        [detectRadius] - Same coordinate system as the given geometry. Required if geometry is not in world-coords.\n\n    this.snapping2DOverlay = function(intersectPoint, meshes, filter, detectRadius) {\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.radius = detectRadius || this.setDetectRadius(intersectPoint);\n        \n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n             \n        for (var i=0; i<meshes.length; i++) {\n            var mesh = meshes[i];\n            var vbr = new VertexBufferReader(mesh.geometry);\n            vbr.enumGeoms(filter, gc);\n        }\n         \n        this.finishSnapping2D(gc, intersectPoint);\n    }\n\n    // Performs 2D snapping to segments based on an enumSegments() callback, which enumerates all segments\n    // within in a given bbox in model-space.\n    //  @param {Vector3}                          intersectPoint (3D with z=0)\n    //  @param {function(minx, miny, maxx, maxy)} enumSegments\n    this.snapping2DWithSegmentEnum = function(intersectPoint, enumSegments) {\n\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.radius = this.setDetectRadius(intersectPoint);\n\n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n        // enum all segments within the snapRadius around intersectPoint\n        var minx = intersectPoint.x - _snapResult.radius;\n        var miny = intersectPoint.y - _snapResult.radius;\n        var maxx = intersectPoint.x + _snapResult.radius;\n        var maxy = intersectPoint.y + _snapResult.radius;\n        enumSegments(minx, miny, maxx, maxy, gc);\n\n        this.finishSnapping2D(gc, intersectPoint);\n    }\n\n    // Finish 2D snapping operation - assuming that all candidate geometry for snapping has been processed by the geometryCallback gc already.\n    this.finishSnapping2D = function(gc, intersectPoint) {\n\n        // When restricting to a single viewport, exclude candidates of all other viewports\n        if (_forcedVpId !== null) {\n            const isSameViewport = c => (c.viewportId === _forcedVpId);\n            gc.snapCandidates = gc.snapCandidates.filter(isSameViewport);\n        }\n\n        // Check if we can snap to an intersection of two close segments\n        const intersectSnap = findIntersectionSnap(gc.snapCandidates, intersectPoint, gc.detectRadius);\n        if (intersectSnap) {\n            _snapResult.viewportIndex2d = intersectSnap.viewportId;\n            _snapResult.snapPoint = intersectSnap.snapPoint;\n            _snapResult.geomType = SnapType.SNAP_INTERSECTION;\n            _snapResult.geomVertex = intersectSnap.snapPoint;\n            _isSnapped = true;\n            return;\n        }\n\n        if (gc.circularArc) {\n\n            _snapResult.viewportIndex2d = gc.vpIdCircular;\n\n            _snapResult.snapPoint = gc.snapPoint;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            if (intersectPoint.distanceTo(gc.circularArc.vertices[0]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.circularArc.vertices[0];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (intersectPoint.distanceTo(gc.circularArc.vertices[gc.circularArc.vertices.length - 1]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else {\n\n                this.lineStripToPieces(gc.circularArc);\n                _snapResult.geomEdge = gc.circularArc;\n                _snapResult.circularArcCenter = gc.circularArcCenter;\n                _snapResult.circularArcRadius = gc.circularArcRadius;\n                _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n            }\n\n            _isSnapped = true;\n\n\n        }\n        else if (gc.ellipticalArc) {\n\n            _snapResult.viewportIndex2d = gc.vpIdElliptical;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[0]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.ellipticalArc.vertices[0];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1]) < _snapResult.radius) {\n\n                _snapResult.geomVertex = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else {\n\n                this.lineStripToPieces(gc.ellipticalArc);\n                _snapResult.geomEdge = gc.ellipticalArc;\n                // Before we have measure design for elliptical arc, measure the center for now\n                _snapResult.circularArcCenter = gc.ellipticalArcCenter;\n                _snapResult.circularArcRadius = null;\n                _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n            }\n\n            _isSnapped = true;\n\n        }\n        else if (gc.lineGeom.vertices.length) {\n\n            _snapResult.viewportIndex2d = gc.vpIdLine;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            // Always expose edge segment - no matter whether we snap to the edge or one of its vertices.\n            // This allows us to combine it with other snap constraints later - as done by Edit2D.\n            _snapResult.geomEdge = gc.lineGeom;\n\n            if (this.markupMode) {  // Markup mode\n                var start = gc.lineGeom.vertices[0];\n                var end = gc.lineGeom.vertices[1];\n                var mid = new THREE.Vector3();\n                mid.addVectors(start, end);\n                mid.divideScalar(2);\n                var md = intersectPoint.distanceTo(mid);\n                var sd = intersectPoint.distanceTo(start);\n                var ed = intersectPoint.distanceTo(end);\n\n                // Store it for snapping to parallel/perpendicular of underlying vectors\n                _snapResult.geomEdge = gc.lineGeom;\n\n                if (md < _snapResult.radius) {\n                    _snapResult.geomVertex = mid;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else if (sd < _snapResult.radius) {\n                    _snapResult.geomVertex = start;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else if (ed < _snapResult.radius) {\n                    _snapResult.geomVertex = end;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n\n                // Circle center\n                if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n                    _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n                }\n            }\n            else {  // Measure mode\n                if (intersectPoint.distanceTo(gc.lineGeom.vertices[0]) < _snapResult.radius) {\n\n                    if (gc.lineGeom.vertices[0].distanceTo(gc.lineGeom.vertices[1]) < EPSILON) {\n                        _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n                    } else {\n                        _snapResult.geomType = SnapType.SNAP_VERTEX;\n                    }\n\n                    _snapResult.geomVertex = gc.lineGeom.vertices[0];\n                }\n                else if ((_options.forceSnapVertices || (intersectPoint.distanceTo(gc.lineGeom.vertices[1]) < _snapResult.radius))) {\n\n                    _snapResult.geomVertex = gc.lineGeom.vertices[1];\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n            }\n\n            _isSnapped = true;\n        }\n    };\n\n    this.snappingRasterPixel = function(result) {\n        if (!result) {\n            return;\n        }\n        \n        var intersectPoint = result.intersectPoint;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.hasTopology = false;\n\n        // Determine which one should be drawn: line, circular arc or elliptical arc\n        _snapResult.radius = this.setDetectRadius(intersectPoint);\n        _snapResult.geomType = SnapType.RASTER_PIXEL;\n        _snapResult.geomVertex = intersectPoint;\n        _isSnapped = true;\n    };\n\n    this.snapMidpoint = function() {\n        _snapResult.isMidpoint = false;\n\n        // Snap midpoint for edge\n        if (_isSnapped) {\n            if (_snapResult.geomType === SnapType.SNAP_EDGE) {\n                var edge = _snapResult.geomEdge;\n                var p1 = edge.vertices[0];\n                var p2 = edge.vertices[1];\n\n                var midpoint = new THREE.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n\n                if (_snapResult.intersectPoint.distanceTo(midpoint) < 2 * _snapResult.radius) {\n                    _snapResult.geomVertex = midpoint;\n                    _snapResult.geomType = SnapType.SNAP_MIDPOINT;\n                }\n            }\n        }\n    };\n\n    this.setPerpendicular = function(isPerpendicular) {\n        _snapResult.isPerpendicular = isPerpendicular;\n    };\n\n    this.lineStripToPieces = function(geom) {\n\n        var vertices = geom.vertices;\n        for (var i = vertices.length - 2; i > 0; i--) {\n            vertices.splice(i, 0, vertices[i]);\n        }\n    };\n\n    this.setDetectRadius = function(point) {\n\n        var navapi = _viewer.navigation;\n        var camera = navapi.getCamera();\n        var position = navapi.getPosition();\n\n        var p = point.clone();\n\n        var distance = camera.isPerspective ? p.sub(position).length()\n            : navapi.getEyeVector().length();\n\n        var fov = navapi.getVerticalFov();\n        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n        var viewport = navapi.getScreenViewport();\n        var _window = this.getWindow();\n        var devicePixelRatio = _window.devicePixelRatio || 1;\n        var radius = this.detectRadiusInPixels * worldHeight / (viewport.height * devicePixelRatio);\n\n        return radius;\n    };\n\n    this.handleButtonDown = function (event, button) {\n        _isDragging = true;\n        return false;\n    };\n\n    this.handleButtonUp = function (event, button) {\n        _isDragging = false;\n        return false;\n    };\n\n    this.handleMouseMove = function (event) {\n\n        if (_isDragging)\n            return false;\n\n        this.onMouseMove({ \n            x: event.canvasX, \n            y: event.canvasY \n        });\n\n        return false;\n    };\n\n    this.handleSingleTap = function(event) {\n\n        return this.handleMouseMove(event);\n    };\n\n    this.handlePressHold = function (event) {\n        \n        if (av.isMobileDevice()) {\n            switch( event.type )\n            {\n                case \"press\":\n                    _isPressing = true;\n                    this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                    break;\n\n                case \"pressup\":\n                    this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                    _isPressing = false;\n                    break;\n            }\n        }\n        return false;\n\n    };\n\n    this.handleGesture = function( event )\n    {   \n        if (av.isMobileDevice()) {\n            if (_isPressing) {\n                switch( event.type )\n                {\n                    case \"dragstart\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        break;\n\n                    case \"dragmove\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        break;\n\n                    case \"dragend\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        _isPressing = false;\n                        break;\n\n                    case \"pinchstart\":\n                        \n                        break;\n\n                    case \"pinchmove\":\n                        break;\n\n                    case \"pinchend\":\n                        break;\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Handler to mouse move events, used to snap in markup edit mode.\n     * @private\n     */\n    this.onMouseDown = function(mousePosition) {\n        return this.onMouseMove(mousePosition);\n    };\n\n    /**\n     * Handler to mouse move events, used to snap in markup edit mode.\n     * @private\n     */\n    this.onMouseMove = function(mousePosition) {\n\n        this.clearSnapped();\n\n        var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);\n\n        if (!result && _snapToPixel) {\n            var vpVec = _viewer.impl.clientToViewport(mousePosition.x, mousePosition.y);\n            let point = _viewer.impl.intersectGroundViewport(vpVec);\n            result = { intersectPoint : point };\n        }\n\n        if (!result || !result.intersectPoint) \n            return false;\n\n        // 3D Snapping\n        if (result.face) {\n            this.snapping3D(result);\n        }\n        // 2D Snapping\n        else if (result.dbId || result.dbId === 0){\n            this.snapping2D(result);\n        }\n        // Pixel Snapping\n        else {\n            const isPixelSnap = _snapToPixel || result.model?.isLeaflet() || (_viewer.impl.is2d && _viewer.model?.isLeaflet());\n            if (isPixelSnap) {\n                this.snappingRasterPixel(result);\n            }\n        }\n\n        this.snapMidpoint();\n\n        return true;\n    };\n};\n\nav.GlobalManagerMixin.call(Snapper.prototype);\n","\n// Collection of static math functions used for snapping implementation\n\n// Find closest point to p on a circular arc. \n//  @param {Vector2} center\n//  @param {number} radius\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 means direction x+\n//  @param {Vector2} [outPoint]\n//  @param {Vector2}\nexport const nearestPointOnCircularArc = (p, center, radius, startAngle, endAngle, outPoint) => {\n\n    outPoint = outPoint || new THREE.Vector2();\n\n    // get normalized direction from circle center to p.\n    // dir = (p-center).normalized()\n    const dir = outPoint.copy(p).sub(center).normalize();\n\n    // If the point is within the arc, we are done\n    const angle = Math.atan2(dir.y, dir.x);\n    const insideArc = Autodesk.Extensions.CompGeom.angleInsideArc(angle, startAngle, endAngle);\n    if (insideArc) {\n        // The ray from center towards p intersects the circle arc.\n        // So, we obtain the closest point by projecting p onto the circle.\n        //\n        // Since dir is the normalized direction from center to p, we obtain the circle projection by:\n        //  onCircleArc = center + dir * radius\n        return dir.multiplyScalar(radius).add(center);\n    }\n\n    // The closest point on the circle is not on the arc.\n    // Then the closest point must be one of the arc ends. Note that this conclusion\n    // can only be made for circles, but not for ellipses with different radii.\n    const pStart = Autodesk.Extensions.CompGeom.getEllipsePoint(startAngle, center.x, center.y, radius, radius);\n    const pEnd   = Autodesk.Extensions.CompGeom.getEllipsePoint(endAngle, center.x, center.y, radius, radius);\n\n    const d2Start = pStart.distanceToSquared(p);\n    const d2End   = pEnd.distanceToSquared(p);\n    const startIsCloser = d2Start <= d2End;\n\n    outPoint.copy(startIsCloser ? pStart : pEnd);\n    return outPoint;\n};\n\n// Compute intersection of two line segments\n// based on http://www.paulbourke.net/geometry/pointlineplane/\n//  @param {Vector2} p1, p2               - First line segment\n//  @param {Vector2} p3, p4               - Second line segment\n//  @param {bool}    [checkInsideSegment] - If true, we reject line intersections outside the segment ranges\n//  @param {Vector2} [outPoint]           - Optional target vector\n//  @param {number}  [epsilon]            - Nearly-zero threshold used to determine \"nearly-parallel\" resp. \"nearly-zero-length line\"\n//  @param {Vector2|null}\nexport const intersectLines = (p1, p2, p3, p4, checkInsideSegment, outPoint, epsilon = 0.00001) => {\n    \n    const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    \n    // Reject if lines are parallel or one of them has zero-length\n    if (Math.abs(denom) < epsilon) {\n        return null;\n    }\n\n    // ua denotes where to find the intersection point p along segment (p1, p2):\n    //   For ua = 0, we have p = p1\n    //   For ua = 1, we have p = p2\n    let ua = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);\n    ua /= denom;\n    \n    // Apply segment check\n    if (checkInsideSegment) {\n\n        // ub denotes where to find the intersection point p along segment (p3, p4)\n        let ub = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);\n        ub /= denom;\n\n        // Intersection is within the segments if ua and ub are both in [0,1]\n        if (ua < 0.0 || ua > 1.0 || \n            ub < 0.0 || ub > 1.0) {\n            return null;\n        }\n    }\n    \n    outPoint = outPoint || new THREE.Vector2();\n    \n    outPoint.x = p1.x + ua * (p2.x - p1.x);\n    outPoint.y = p1.y + ua * (p2.y - p1.y);\n    return outPoint;\n};\n\n\n\n","const MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst isEqualVectors = MeasureCommon.isEqualVectors;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\n\n    var NO_OVERLAY = 0;\n    var FACE_OVERLAY = 1;\n    var EDGE_OVERLAY = 2;\n    var POINT_OVERLAY = 3;\n    \n    var GEOMETRIES_OVERLAY = 'MeasureTool-snapper-geometries';\n    var INDICATOR_OVERLAY = 'MeasureTool-snapper-indicator';\n\n    var _geometryLineWidth = 0.3;\n    var _indicatorLineWidth = 0.2;\n    var _indicatorSize = 1.2;\n    var _point = null;\n\n    var _indicatorColor = 0xff7700;\n    var _geometryColor = 0x00CC00;\n\n    // /** @constructor */\n    export function SnapperIndicator( viewer, snapper )\n    {\n        this.viewer = viewer;\n        this.snapper = snapper;\n        this.overlayType = NO_OVERLAY;\n        this.previewsIntersectPoint = null;\n\n        this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n        this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n        this.geometryMaterial = new THREE.MeshPhongMaterial({\n            color: _geometryColor,\n            ambient: _geometryColor,\n            opacity: 0.5,\n            transparent: true,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n\n        this.indicatorMaterial = new THREE.MeshBasicMaterial({\n            color: _indicatorColor,\n            ambient: _indicatorColor,\n            opacity: 1,\n            transparent: false,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n    }\n\n    SnapperIndicator.prototype.constructor = SnapperIndicator;\n    var proto = SnapperIndicator.prototype;\n\n\n    proto.render = function() {\n\n        var snapResult = this.snapper.getSnapResult();\n\n        if (!isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n            this.clearOverlay(GEOMETRIES_OVERLAY);\n        }\n        \n        this.clearOverlay(INDICATOR_OVERLAY);\n\n        if (snapResult.isEmpty())\n            return;\n\n        if (this.snapper.renderSnappedGeometry ||\n            (snapResult.hasTopology && this.snapper.renderSnappedTopology)) {\n            this.renderGeometry(snapResult);\n        }\n        this.renderIndicator(snapResult);\n\n        this.previewsIntersectPoint = snapResult.intersectPoint.clone();\n    };\n\n    proto.removeOverlay = function(overlayName) {\n        \n        this.viewer.impl.clearOverlay(overlayName);\n        this.viewer.impl.removeOverlayScene(overlayName);\n\n    };\n\n    proto.clearOverlay = function(overlayName) {\n        \n        this.removeOverlay(overlayName);\n        this.viewer.impl.createOverlayScene(overlayName);\n\n    };\n\n    proto.clearOverlays = function() {\n        \n        this.removeOverlay(GEOMETRIES_OVERLAY);\n        this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n\n        this.removeOverlay(INDICATOR_OVERLAY);\n        this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n        this.previewsIntersectPoint = null;\n\n    };\n\n    proto.addOverlay = function(overlayName, mesh) {\n\n        this.viewer.impl.addOverlay(overlayName, mesh);\n\n    };\n\n    /**\n     * Draw the planar face\n     * @param geom -Geometry which needs to be draw.\n     * @param mesh -Mesh which is loaded.\n     */\n    proto.drawFace = function(geom, material, overlayName) {\n\n        var snapperPlane = new THREE.Mesh(geom, material, true);\n\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = FACE_OVERLAY;\n        }\n\n        this.addOverlay(overlayName, snapperPlane);\n\n    };\n\n    proto.cylinderMesh = function(pointX, pointY, material, width) {\n\n        var direction = new THREE.Vector3().subVectors(pointY, pointX);\n        var orientation = new THREE.Matrix4();\n        orientation.lookAt(pointX, pointY, new THREE.Object3D().up);\n        orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,\n            0, 0, 1, 0,\n            0, -direction.length(), 0, 0,\n            0, 0, 0, 1));\n\n        width = width || 0.5;\n        var cylinder = new THREE.CylinderGeometry(width, width, 1.0, 8, 1, true);\n        var edge = new THREE.Mesh(cylinder, material);\n        cylinder = null;\n\n        edge.applyMatrix(orientation);\n        edge.position.x = (pointY.x + pointX.x) / 2;\n        edge.position.y = (pointY.y + pointX.y) / 2;\n        edge.position.z = (pointY.z + pointX.z) / 2;\n        return edge;\n\n    };\n\n    proto.renderGeometry = function(snapResult) {\n\n        if (isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)){\n            return;\n        }\n\n        switch (snapResult.geomType) {\n            case SnapType.SNAP_VERTEX:\n                 SnapType.RASTER_PIXEL;\n                this.drawPoint(snapResult.geomVertex, this.geometryMaterial, GEOMETRIES_OVERLAY);\n                break;\n\n            case SnapType.SNAP_EDGE:\n            case SnapType.SNAP_CURVEDEDGE:\n            case SnapType.SNAP_CIRCULARARC:\n            case SnapType.SNAP_MIDPOINT:\n                this.drawLine(snapResult.geomEdge, this.geometryMaterial, _geometryLineWidth, GEOMETRIES_OVERLAY);\n                break;\n\n            case SnapType.SNAP_FACE:\n            case SnapType.SNAP_CURVEDFACE:\n                this.drawFace(snapResult.geomFace, this.geometryMaterial, GEOMETRIES_OVERLAY);\n                break;\n        }\n    };\n\n    proto.renderVertexIndicator = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Upper line\n        p.addVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.addVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderMidpointIndicator = function(snapResult) {\n\n        var pos = snapResult.geomVertex;\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.addVectors(pos, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.addVectors(pos, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderEdgeIndicator = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderCircleIndicator = function(snapResult){\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        this.drawCircle(pos, this.indicatorMaterial, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderPerpendicular = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Upper line\n        geom.vertices[0] = pos.clone();\n        p.subVectors(pos, rightVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        geom.vertices[0] = pos.clone();\n        p.subVectors(pos, upVec);\n        geom.vertices[1] = p.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    };\n\n    proto.renderPixelIndicator = function(snapResult) {\n\n        var pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        var scale = this.setScale(pos);\n        var length = _indicatorSize * scale;\n\n        var rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        var upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        var geom = new THREE.Geometry();\n        var p = new THREE.Vector3();\n\n        // Top-left line\n        p.subVectors(pos, rightVec);\n        p.addVectors(p,upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Top-right line\n        p.addVectors(pos, rightVec);\n        p.addVectors(p,upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom-right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n        \n        // Bottom-left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        geom.vertices[0] = p.clone();\n        geom.vertices[1] = pos.clone();\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n\n    };\n\n    proto.renderIndicator = function(snapResult) {\n\n        if (snapResult.isPerpendicular) {\n            this.renderPerpendicular(snapResult);\n            return;\n        }\n\n        switch (snapResult.geomType) {\n            case SnapType.SNAP_VERTEX:            \n                this.renderVertexIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_INTERSECTION:\n                this.renderVertexIndicator(snapResult);\n                break;\n    \n            case SnapType.SNAP_MIDPOINT:\n                this.renderMidpointIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_CIRCLE_CENTER:\n                this.renderCircleIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_EDGE:\n            case SnapType.SNAP_CURVEDEDGE:\n                this.renderEdgeIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_CIRCULARARC:\n                if (this.viewer.model.is2d()) {\n                    this.renderVertexIndicator(snapResult);\n                } else {\n                    this.renderCircleIndicator(snapResult);\n                }\n                break;\n\n            case SnapType.SNAP_FACE:\n            case SnapType.SNAP_CURVEDFACE:\n                this.renderVertexIndicator(snapResult);\n                break;\n\n            case SnapType.RASTER_PIXEL:\n                this.renderPixelIndicator(snapResult);\n                break;\n        }\n    };\n\n    proto.drawLine = function(geom, material, width, overlayName) {\n\n        // Line Pieces\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = EDGE_OVERLAY;    \n        }\n        \n        for (var i = 0; i < geom.vertices.length; i += 2) {\n            var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, width);\n            this.setEdgeScale(cylinder);\n            this.addOverlay(overlayName, cylinder);\n        }\n    };\n\n    proto.drawPoint = function(point, material, overlayName) {\n        \n        // Because every point is snappable in PDFs, don't display the green dot for PDFs.\n        if (this.viewer.model.isLeaflet()) {\n            return;\n        }\n\n        if (!_point)\n            _point = new THREE.SphereGeometry(1.0);\n\n        var pointMesh = new THREE.Mesh(_point, material);\n        pointMesh.position.set(point.x, point.y, point.z);\n\n        this.setPointScale(pointMesh);\n\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = POINT_OVERLAY;\n        }\n\n        this.addOverlay(overlayName, pointMesh);\n\n    };\n\n    proto.drawCircle = function(point, material, overlayName) {\n\n        var torus = new THREE.TorusGeometry(_indicatorSize, _indicatorLineWidth, 2, 20);\n        var torusMesh = new THREE.Mesh(torus, material);\n        torusMesh.lookAt(this.viewer.navigation.getEyeVector().normalize());\n        torus = null;\n\n        torusMesh.position.set(point.x, point.y, point.z);\n\n        this.setCircleScale(torusMesh);\n\n        this.addOverlay(overlayName, torusMesh);\n\n    };\n\n    proto.setScale = function (point) {\n\n        var pixelSize = 5;\n\n        var navapi = this.viewer.navigation;\n        var camera = navapi.getCamera();\n        var position = navapi.getPosition();\n\n        var p = point.clone();\n\n        var distance = camera.isPerspective ? p.sub(position).length()\n            : navapi.getEyeVector().length();\n\n        var fov = navapi.getVerticalFov();\n        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n        var viewport = navapi.getScreenViewport();\n        var scale = pixelSize * worldHeight / viewport.height;\n\n        return scale;\n\n    };\n\n    proto.setPointScale = function (pointMesh) {\n\n        var scale = this.setScale(pointMesh.position);\n        pointMesh.scale.x = scale;\n        pointMesh.scale.y = scale;\n        pointMesh.scale.z = scale;\n\n    };\n\n    proto.setCircleScale = function (torusMesh) {\n\n        var scale = this.setScale(torusMesh.position);\n        torusMesh.scale.x = scale;\n        torusMesh.scale.y = scale;\n    };\n\n    proto.setEdgeScale = function (cylinderMesh) {\n\n        var scale = this.setScale(cylinderMesh.position);\n        cylinderMesh.scale.x = scale;\n        cylinderMesh.scale.z = scale;\n    };\n\n    proto.updatePointScale = function(overlayName) {\n\n        if (this.overlayType != POINT_OVERLAY)\n            return;\n\n        var overlay = this.viewer.impl.overlayScenes[overlayName];\n        if (overlay) {\n            var scene = overlay.scene;\n\n            for (var i = 0; i < scene.children.length; i++) {\n                var pointMesh = scene.children[i];\n                if (pointMesh) {\n\n                    this.setPointScale(pointMesh);\n                }\n            }\n        }\n    };\n\n    proto.updateEdgeScale = function(overlayName) {\n\n        if (this.overlayType != EDGE_OVERLAY)\n            return;\n\n        var overlay = this.viewer.impl.overlayScenes[overlayName];\n        if (overlay) {\n            var scene = overlay.scene;\n\n            for (var i = 0; i < scene.children.length; i++) {\n                var cylinderMesh = scene.children[i];\n                if (cylinderMesh) {\n\n                    this.setEdgeScale(cylinderMesh);\n                }\n            }\n        }\n    };\n\n    proto.onCameraChange = function () {\n\n        this.updatePointScale(GEOMETRIES_OVERLAY);\n        this.updateEdgeScale(GEOMETRIES_OVERLAY);\n\n        // if (!this.snapper.markupMode) {\n            this.render();\n        // }\n    };\n\n    proto.destroy = function() {\n\n        this.removeOverlay(GEOMETRIES_OVERLAY);\n        this.removeOverlay(INDICATOR_OVERLAY);\n\n        if (_point) {\n            _point.dispose();\n            _point = null;\n        }\n    };\n\n"],"sourceRoot":""}